import { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport React from 'react'\n\n// Mock fetch for error reporting\nglobal.fetch = jest.fn()\n\n// Component that throws an error\nconst ThrowError = ({ shouldThrow }: { shouldThrow: boolean }) => {\n  if (shouldThrow) {\n    throw new Error('Test error message')\n  }\n  return <div>No error</div>\n}\n\n// Component that throws a network error\nconst ThrowNetworkError = ({ shouldThrow }: { shouldThrow: boolean }) => {\n  if (shouldThrow) {\n    throw new Error('ChunkLoadError: Loading chunk 123 failed')\n  }\n  return <div>No error</div>\n}\n\ndescribe('ErrorBoundary', () => {\n  beforeEach(() => {\n    jest.clearAllMocks()\n    jest.spyOn(console, 'error').mockImplementation(() => {})\n    ;(global.fetch as jest.Mock).mockResolvedValue({\n      ok: true,\n      json: async () => ({ success: true })\n    })\n  })\n\n  afterEach(() => {\n    jest.restoreAllMocks()\n  })\n\n  describe('Error Catching', () => {\n    it('should render children when there is no error', () => {\n      render(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={false} />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText('No error')).toBeInTheDocument()\n    })\n\n    it('should render error UI when child throws an error', () => {\n      render(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument()\n      expect(screen.getByText(/We encountered an unexpected error/)).toBeInTheDocument()\n    })\n\n    it('should display error ID for reporting', () => {\n      render(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText(/Error ID:/)).toBeInTheDocument()\n      expect(screen.getByText(/Please include this ID when reporting/)).toBeInTheDocument()\n    })\n\n    it('should render custom fallback if provided', () => {\n      const customFallback = <div>Custom error message</div>\n      \n      render(\n        <ErrorBoundary fallback={customFallback}>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText('Custom error message')).toBeInTheDocument()\n    })\n  })\n\n  describe('Error Reporting', () => {\n    it('should report error to API in production', async () => {\n      const originalEnv = process.env.NODE_ENV\n      process.env.NODE_ENV = 'production'\n\n      render(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      await waitFor(() => {\n        expect(global.fetch).toHaveBeenCalledWith('/api/errors', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: expect.stringContaining('Test error message')\n        })\n      })\n\n      process.env.NODE_ENV = originalEnv\n    })\n\n    it('should include error details in report', async () => {\n      const originalEnv = process.env.NODE_ENV\n      process.env.NODE_ENV = 'production'\n\n      render(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      await waitFor(() => {\n        const fetchCall = (global.fetch as jest.Mock).mock.calls[0]\n        const body = JSON.parse(fetchCall[1].body)\n        \n        expect(body).toMatchObject({\n          message: 'Test error message',\n          errorId: expect.stringMatching(/^err_\\d+_[a-z0-9]+$/),\n          userAgent: expect.any(String),\n          url: expect.any(String),\n          timestamp: expect.any(String)\n        })\n      })\n\n      process.env.NODE_ENV = originalEnv\n    })\n  })\n\n  describe('Auto-retry Mechanism', () => {\n    it('should auto-retry for network errors', async () => {\n      const { rerender } = render(\n        <ErrorBoundary>\n          <ThrowNetworkError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText('Retrying...')).toBeInTheDocument()\n      expect(screen.getByText(/Attempting to recover/)).toBeInTheDocument()\n\n      // Wait for auto-retry\n      await waitFor(() => {\n        expect(screen.queryByText('Retrying...')).not.toBeInTheDocument()\n      }, { timeout: 3000 })\n    })\n\n    it('should not auto-retry for regular errors', () => {\n      render(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      expect(screen.queryByText('Retrying...')).not.toBeInTheDocument()\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument()\n    })\n\n    it('should stop retrying after max attempts', async () => {\n      const RetryComponent = ({ attempt }: { attempt: number }) => {\n        if (attempt < 4) { // Will retry 3 times\n          throw new Error('ChunkLoadError: Loading chunk failed')\n        }\n        return <div>Success after retries</div>\n      }\n\n      let attempt = 0\n      const { rerender } = render(\n        <ErrorBoundary>\n          <RetryComponent attempt={attempt} />\n        </ErrorBoundary>\n      )\n\n      // Simulate multiple retry attempts\n      for (let i = 1; i <= 4; i++) {\n        await waitFor(() => {\n          attempt = i\n          rerender(\n            <ErrorBoundary>\n              <RetryComponent attempt={attempt} />\n            </ErrorBoundary>\n          )\n        })\n      }\n\n      await waitFor(() => {\n        expect(screen.queryByText('Try Again')).not.toBeInTheDocument()\n      })\n    })\n  })\n\n  describe('User Actions', () => {\n    it('should provide retry button for retryable errors', () => {\n      render(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByRole('button', { name: /try again/i })).toBeInTheDocument()\n    })\n\n    it('should provide reload button', () => {\n      const mockReload = jest.fn()\n      Object.defineProperty(window, 'location', {\n        value: { reload: mockReload },\n        writable: true\n      })\n\n      render(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      fireEvent.click(screen.getByRole('button', { name: /reload page/i }))\n      expect(mockReload).toHaveBeenCalled()\n    })\n\n    it('should provide home navigation button', () => {\n      Object.defineProperty(window, 'location', {\n        value: { href: '' },\n        writable: true\n      })\n\n      render(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      fireEvent.click(screen.getByRole('button', { name: /go home/i }))\n      expect(window.location.href).toBe('/')\n    })\n\n    it('should provide bug report functionality', () => {\n      const mockOpen = jest.fn()\n      Object.defineProperty(window, 'open', {\n        value: mockOpen,\n        writable: true\n      })\n\n      render(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      fireEvent.click(screen.getByRole('button', { name: /report issue/i }))\n      expect(mockOpen).toHaveBeenCalledWith(\n        expect.stringContaining('mailto:support@launchboost.com'),\n        '_blank'\n      )\n    })\n  })\n\n  describe('Development Mode', () => {\n    it('should show error details in development', () => {\n      const originalEnv = process.env.NODE_ENV\n      process.env.NODE_ENV = 'development'\n\n      render(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText('Error Details (Development)')).toBeInTheDocument()\n      \n      // Click to expand details\n      fireEvent.click(screen.getByText('Error Details (Development)'))\n      expect(screen.getByText(/Test error message/)).toBeInTheDocument()\n\n      process.env.NODE_ENV = originalEnv\n    })\n\n    it('should not show error details in production', () => {\n      const originalEnv = process.env.NODE_ENV\n      process.env.NODE_ENV = 'production'\n\n      render(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      expect(screen.queryByText('Error Details (Development)')).not.toBeInTheDocument()\n\n      process.env.NODE_ENV = originalEnv\n    })\n  })\n\n  describe('Reset Functionality', () => {\n    it('should reset when resetKeys change', () => {\n      const { rerender } = render(\n        <ErrorBoundary resetKeys={['key1']}>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument()\n\n      // Change reset keys\n      rerender(\n        <ErrorBoundary resetKeys={['key2']}>\n          <ThrowError shouldThrow={false} />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText('No error')).toBeInTheDocument()\n    })\n\n    it('should reset when children change if resetOnPropsChange is true', () => {\n      const { rerender } = render(\n        <ErrorBoundary resetOnPropsChange={true}>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument()\n\n      rerender(\n        <ErrorBoundary resetOnPropsChange={true}>\n          <ThrowError shouldThrow={false} />\n        </ErrorBoundary>\n      )\n\n      expect(screen.getByText('No error')).toBeInTheDocument()\n    })\n\n    it('should call onError callback when error occurs', () => {\n      const onError = jest.fn()\n      \n      render(\n        <ErrorBoundary onError={onError}>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      expect(onError).toHaveBeenCalledWith(\n        expect.any(Error),\n        expect.objectContaining({\n          componentStack: expect.any(String)\n        })\n      )\n    })\n  })\n\n  describe('Accessibility', () => {\n    it('should have proper ARIA labels and roles', () => {\n      render(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      )\n\n      const buttons = screen.getAllByRole('button')\n      buttons.forEach(button => {\n        expect(button).toHaveAccessibleName()\n      })\n    })\n  })\n})\n